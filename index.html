<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reach Out Database</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@32.0.2/dist/ag-grid-enterprise.min.js"></script>
  <style>
    :root {
      --ink: #101828;
      --muted: #667085;
      --bg: #f5f7fb;
      --card: #ffffff;
      --accent: #1d4ed8;
      --accent-2: #0f766e;
      --border: #e4e7ec;
      --shadow: 0 1px 2px rgba(16, 24, 40, 0.06), 0 1px 3px rgba(16, 24, 40, 0.1);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
    }

    body {
      font-family: "IBM Plex Sans", "Segoe UI", Arial, sans-serif;
      color: var(--ink);
      background: var(--bg);
    }

    .app {
      max-width: 100%;
      margin: 0 auto;
      padding: 16px 20px 12px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
    }

    .tabs {
      display: flex;
      gap: 20px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 8px;
      flex-shrink: 0;
    }

    .tab {
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 8px 4px;
      font-size: 13px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
    }

    .tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
      font-weight: 600;
    }

    .toolbar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0 12px;
      flex-shrink: 0;
    }

    .panel {
      display: none;
      margin-top: 12px;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--card);
      box-shadow: var(--shadow);
    }

    .panel.active {
      display: block;
    }

    .panel label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    .panel input,
    .panel select,
    .panel textarea {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-family: "IBM Plex Sans", "Segoe UI", Arial, sans-serif;
      font-size: 13px;
    }

    .panel textarea {
      min-height: 120px;
      resize: vertical;
      font-family: "IBM Plex Sans", "Segoe UI", Arial, sans-serif;
    }

    .panel-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }

    .panel-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .snippet {
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #f8fafc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .mcp-info {
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #ffffff;
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .toolbar input,
    .toolbar select {
      flex: 1;
      min-width: 220px;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 14px;
      font-family: "IBM Plex Sans", "Segoe UI", Arial, sans-serif;
      background: #fff;
    }

    .toolbar select {
      max-width: 160px;
    }

    .btn {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--card);
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
    }

    .btn.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .btn.success {
      background: var(--accent-2);
      color: #fff;
      border-color: var(--accent-2);
    }

    .btn.tiny {
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 999px;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .checkbox-cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .checkbox-cell input {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      overflow: hidden;
      flex: 1 1 0;
      min-height: 0;
      max-height: calc(100vh - 160px);
    }

    #grid {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .detail-panel {
      padding: 12px 16px;
      background: #ffffff;
    }

    .detail-grid {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .contact {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      min-width: 220px;
      max-width: 320px;
    }

    .contact .name { font-weight: 600; }
    .contact .title { font-size: 12px; color: var(--muted); margin-top: 4px; white-space: pre-wrap; }
    .contact a { font-size: 12px; color: #0a66c2; text-decoration: none; }

    .footer {
      margin-top: 8px;
      padding: 4px 0;
      font-size: 10px;
      color: var(--muted);
      text-align: center;
      flex-shrink: 0;
    }

    .ag-theme-alpine {
      --ag-font-family: "IBM Plex Sans", "Segoe UI", Arial, sans-serif;
      --ag-header-background-color: #f8fafc;
      --ag-row-hover-color: #f1f5ff;
      --ag-border-color: #e4e7ec;
      --ag-odd-row-background-color: #ffffff;
      --ag-row-height: 28px;
      --ag-header-height: 32px;
      --ag-selected-row-background-color: #ffffff;
      --ag-range-selection-border-color: transparent;
      --ag-range-selection-highlight-color: transparent;
    }

    .ag-row-focus,
    .ag-cell-focus {
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }

    .ag-row-focus .ag-cell {
      border-color: var(--ag-border-color);
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="tabs">
      <button class="tab active" data-category="founders">Founders</button>
      <button class="tab" data-category="researchers">Researchers</button>
      <button class="tab" data-category="vcs">VCs</button>
      <button class="tab" data-category="angels">Angel investors</button>
      <button class="tab" data-category="hires">Hires</button>
      <button class="tab" data-category="mcp">MCP</button>
    </div>

    <div class="toolbar">
      <input id="search" type="text" placeholder="Search names, tags, links, or notes..." />
      <select id="city-filter">
        <option value="all">All cities</option>
        <option value="SF">SF</option>
        <option value="NYC">NYC</option>
        <option value="other">Other</option>
      </select>
      <button class="btn primary" id="btn-add">Add Row</button>
      <button class="btn success" id="btn-sync">Save/Sync</button>
      <button class="btn tiny" id="toggle-expand">Expand all</button>
      <button class="btn" id="btn-download">Download JSON</button>
      <span class="muted" id="sync-status"></span>
    </div>

    <div class="card">
      <div id="grid" class="ag-theme-alpine"></div>
    </div>

    <div class="panel" id="mcp-panel">
      <div class="panel-row">
        <input id="mcp-endpoint" type="text" value="/api/mcp" />
        <button class="btn" id="mcp-copy">Copy</button>
      </div>
      <div class="panel-row">
        <input id="mcp-key" type="text" placeholder="API key (optional; proxied if blank)" />
        <button class="btn" id="mcp-key-copy">Copy Key</button>
      </div>
      <div class="panel-row">
        <input id="mcp-tool" type="text" value="upsert_contact" />
        <button class="btn" id="mcp-snippet-copy">Copy Snippet</button>
      </div>
      <textarea id="mcp-args">{
  "category": "founders",
  "name": "Example Person",
  "patch": { "city": "SF", "tags": ["intro"], "notes": "Reach out later" }
}</textarea>
      <div class="mcp-info" id="mcp-info">Loading MCP overview...</div>
      <div class="snippet" id="mcp-snippet"></div>
      <div class="panel-actions">
        <button class="btn primary" id="mcp-send">Send</button>
        <span class="muted" id="mcp-status"></span>
      </div>
    </div>

    <div class="footer">Local-first database. Data saved per category.</div>
  </div>

  <script>
    const MCP_ENDPOINT_DEFAULT = '/api/mcp';
    const MCP_API_KEY_DEFAULT = '';

    const DATA = {
      founders: { entries: [] },
      researchers: { entries: [] },
      vcs: { firms: [] },
      angels: { entries: [] },
      hires: { entries: [] }
    };

    const state = {
      currentCategory: 'founders',
      gridApi: null,
      expandedAll: false,
      searchQuery: '',
      cityFilter: 'all'
    };

    const STOP_WORDS = new Set(['the', 'and', 'or', 'of', 'for', 'with', 'in', 'to', 'a', 'an']);
    const REQUIRED_FIELDS = ['name'];
    const AUTO_UPSERT_DELAY = 600;
    const pendingUpserts = new Map();

    function checkboxRenderer(params) {
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = Boolean(params.data && params.data.checked);
      input.setAttribute('aria-label', 'Send row to bottom');
      input.addEventListener('click', (event) => {
        event.stopPropagation();
      });
      input.addEventListener('change', () => {
        if (params.data) {
          params.data.checked = input.checked;
          scheduleUpsert(params.data);
        }
        applyCheckedOrdering();
      });
      return input;
    }

    function normalizeList(value) {
      if (!value) return [];
      if (Array.isArray(value)) return value.filter(Boolean);
      return String(value)
        .split(',')
        .map(part => part.trim())
        .filter(Boolean);
    }

    function normalizeCity(value) {
      if (!value) return '';
      const trimmed = String(value).trim();
      if (!trimmed) return '';
      const upper = trimmed.toUpperCase();
      if (['SF', 'SAN FRANCISCO', 'SANFRANCISCO'].includes(upper)) return 'SF';
      if (['NYC', 'NEW YORK', 'NEW YORK CITY'].includes(upper)) return 'NYC';
      if (upper === 'OTHER') return 'Other';
      return trimmed;
    }

    function linksRenderer(params) {
      const links = normalizeList(params.value);
      if (!links.length) return '';
      return links
        .map(link => {
          const href = link.startsWith('http') ? link : `https://${link}`;
          let label = link;
          try {
            label = new URL(href).hostname.replace('www.', '');
          } catch (e) {
            label = link;
          }
          return `<a href="${href}" target="_blank">${label}</a>`;
        })
        .join(', ');
    }

    function xLinkRenderer(params) {
      const value = params.value;
      if (!value) return '';
      let handle = value;
      let href = value;
      if (value.startsWith('http')) {
        try {
          const url = new URL(value);
          handle = '@' + url.pathname.replace(/^\//, '').split('/')[0];
        } catch (e) {
          handle = value;
        }
        href = value;
      } else {
        handle = value.startsWith('@') ? value : '@' + value;
        href = 'https://x.com/' + handle.replace('@', '');
      }
      return `<a href="${href}" target="_blank" style="color:#1da1f2">${handle}</a>`;
    }

    function linkedinRenderer(params) {
      const value = params.value;
      if (!value) return '';
      let href = value;
      let label = 'Profile';
      if (value.startsWith('http')) {
        href = value;
        try {
          const url = new URL(value);
          const parts = url.pathname.split('/').filter(Boolean);
          if (parts.length >= 2) label = parts[1];
        } catch (e) {}
      } else {
        href = 'https://linkedin.com/in/' + value;
        label = value;
      }
      return `<a href="${href}" target="_blank" style="color:#0a66c2">${label}</a>`;
    }

    function buildSearchBlob(row) {
      const tags = normalizeList(row.tags);
      const parts = [
        row.name,
        row.city,
        row.notes,
        row.x,
        row.linkedin,
        row.website,
        ...tags
      ];
      // For VCs, also search through partners
      if (row.partners && Array.isArray(row.partners)) {
        row.partners.forEach(p => {
          parts.push(p.name, p.role, p.notes, p.x, p.linkedin);
        });
      }
      return parts.filter(Boolean).join(' ').toLowerCase();
    }

    function tokenize(query) {
      return query
        .toLowerCase()
        .split(/[^a-z0-9]+/)
        .filter(token => token && !STOP_WORDS.has(token));
    }

    function rowMatchesQuery(row, query) {
      const tokens = tokenize(query);
      if (!tokens.length) return true;
      const blob = buildSearchBlob(row);
      return tokens.every(token => blob.includes(token));
    }

    function rowMatchesCity(row, filter) {
      if (filter === 'all') return true;
      const city = normalizeCity(row.city);
      if (filter === 'other') {
        return city && city !== 'SF' && city !== 'NYC';
      }
      return city === filter;
    }

    const columnDefs = [
      {
        headerName: '',
        width: 44,
        maxWidth: 44,
        resizable: false,
        sortable: false,
        filter: false,
        suppressMenu: true,
        cellClass: 'checkbox-cell',
        cellRenderer: checkboxRenderer
      },
      { field: 'name', headerName: 'Name', flex: 2, minWidth: 180, editable: true },
      { field: 'city', width: 80, editable: true },
      { field: 'tags', headerName: 'Tags', flex: 2, minWidth: 140, editable: true },
      { field: 'x', headerName: 'X', width: 140, editable: true, cellRenderer: xLinkRenderer },
      { field: 'linkedin', headerName: 'LinkedIn', width: 140, editable: true, cellRenderer: linkedinRenderer },
      { field: 'notes', headerName: 'Notes', flex: 3, minWidth: 200, editable: true }
    ];

    // VC-specific columns for firms
    const vcColumnDefs = [
      {
        headerName: '',
        width: 44,
        maxWidth: 44,
        resizable: false,
        sortable: false,
        filter: false,
        suppressMenu: true,
        cellClass: 'checkbox-cell',
        cellRenderer: checkboxRenderer
      },
      {
        headerName: '',
        width: 44,
        maxWidth: 44,
        resizable: false,
        sortable: false,
        filter: false,
        suppressMenu: true,
        cellRenderer: 'agGroupCellRenderer'
      },
      { field: 'name', headerName: 'Firm', flex: 2, minWidth: 200, editable: true },
      { field: 'city', width: 80, editable: true },
      { field: 'tags', headerName: 'Focus', flex: 2, minWidth: 160, editable: true, valueFormatter: params => normalizeList(params.value).join(', ') },
      {
        field: 'website',
        headerName: 'Website',
        width: 140,
        editable: true,
        cellRenderer: params => {
          if (!params.value) return '';
          return `<a href="${params.value}" target="_blank" style="color:var(--accent)">${params.value.replace(/^https?:\/\//, '')}</a>`;
        }
      },
      { field: 'notes', headerName: 'Notes', flex: 3, minWidth: 200, editable: true },
      {
        field: 'partners',
        headerName: 'Partners',
        width: 100,
        valueFormatter: params => params.value ? `${params.value.length} partner${params.value.length !== 1 ? 's' : ''}` : '0'
      }
    ];

    class DetailRenderer {
      init(params) {
        this.eGui = document.createElement('div');
        this.eGui.className = 'detail-panel';
        const tags = normalizeList(params.data.tags).join(', ') || 'No tags.';
        const links = normalizeList(params.data.links)
          .map(link => {
            const href = link.startsWith('http') ? link : `https://${link}`;
            const label = link.replace(/^https?:\/\//, '');
            return `<a href="${href}" target="_blank">${label}</a>`;
          })
          .join('<br />') || 'No links.';
        const notes = params.data.notes ? String(params.data.notes) : 'No notes.';
        this.eGui.innerHTML = `
          <div class="detail-grid">
            <div class="contact">
              <div class="name">Tags</div>
              <div class="title">${tags}</div>
            </div>
            <div class="contact">
              <div class="name">Links</div>
              <div class="title">${links}</div>
            </div>
            <div class="contact">
              <div class="name">Notes</div>
              <div class="title">${notes}</div>
            </div>
          </div>
        `;
      }
      getGui() { return this.eGui; }
      refresh() { return false; }
    }

    // VC-specific detail renderer showing partners
    class VCDetailRenderer {
      init(params) {
        this.eGui = document.createElement('div');
        this.eGui.className = 'detail-panel';
        const partners = params.data.partners || [];
        if (!partners.length) {
          this.eGui.textContent = 'No partners listed.';
          this.eGui.style.color = 'var(--muted)';
          return;
        }
        // Build partner cards using DOM methods for security
        const header = document.createElement('div');
        header.style.cssText = 'margin-bottom:8px;font-weight:600;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:0.5px;';
        header.textContent = `Partners (${partners.length})`;
        this.eGui.appendChild(header);

        const grid = document.createElement('div');
        grid.className = 'detail-grid';
        grid.style.gap = '16px';

        partners.forEach(p => {
          const card = document.createElement('div');
          card.className = 'contact';
          card.style.cssText = 'flex:1;min-width:280px;max-width:400px;';

          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = p.name || 'Unknown';
          card.appendChild(nameEl);

          if (p.role) {
            const roleEl = document.createElement('div');
            roleEl.className = 'title';
            roleEl.style.cssText = 'color:var(--accent);font-weight:500;margin:4px 0;';
            roleEl.textContent = p.role;
            card.appendChild(roleEl);
          }

          const linksDiv = document.createElement('div');
          linksDiv.style.margin = '6px 0';
          if (p.x) {
            const xLink = document.createElement('a');
            xLink.href = 'https://x.com/' + p.x.replace('@', '');
            xLink.target = '_blank';
            xLink.style.color = '#1da1f2';
            xLink.textContent = '@' + p.x.replace('@', '');
            linksDiv.appendChild(xLink);
          }
          if (p.x && p.linkedin) {
            linksDiv.appendChild(document.createTextNode(' Â· '));
          }
          if (p.linkedin) {
            const liLink = document.createElement('a');
            liLink.href = p.linkedin.startsWith('http') ? p.linkedin : 'https://linkedin.com/in/' + p.linkedin;
            liLink.target = '_blank';
            liLink.style.color = '#0a66c2';
            liLink.textContent = 'LinkedIn';
            linksDiv.appendChild(liLink);
          }
          if (p.x || p.linkedin) {
            card.appendChild(linksDiv);
          }

          if (p.notes) {
            const notesEl = document.createElement('div');
            notesEl.className = 'title';
            notesEl.style.marginTop = '8px';
            notesEl.textContent = p.notes;
            card.appendChild(notesEl);
          }

          grid.appendChild(card);
        });

        this.eGui.appendChild(grid);
      }
      getGui() { return this.eGui; }
      refresh() { return false; }
    }

    const gridOptions = {
      columnDefs,
      defaultColDef: { resizable: true, sortable: true, filter: true, minWidth: 120 },
      masterDetail: true,
      detailCellRenderer: DetailRenderer,
      detailRowHeight: 180,
      animateRows: true,
      rowSelection: 'none',
      suppressCellFocus: true,
      enableCharts: true,
      isExternalFilterPresent: () => state.searchQuery.length > 0 || state.cityFilter !== 'all',
      doesExternalFilterPass: node => {
        return rowMatchesQuery(node.data || {}, state.searchQuery) && rowMatchesCity(node.data || {}, state.cityFilter);
      },
      onGridReady: (params) => { state.gridApi = params.api; },
      onCellValueChanged: (params) => {
        syncLocalDataFromGrid();
        scheduleUpsert(params.data);
      }
    };

    function setSyncStatus(message, isError = false) {
      const el = document.getElementById('sync-status');
      if (!el) return;
      el.textContent = message || '';
      el.style.color = isError ? '#b42318' : 'var(--muted)';
    }

    function isBlank(value) {
      return value === undefined || value === null || String(value).trim() === '';
    }

    function rowHasRequiredFields(row) {
      return REQUIRED_FIELDS.every((field) => !isBlank(row[field]));
    }

    function normalizeRowForSync(row, category) {
      const base = {
        id: row.id,
        name: row.name,
        city: normalizeCity(row.city),
        tags: normalizeList(row.tags),
        notes: row.notes || '',
        checked: Boolean(row.checked)
      };
      // VCs have different fields
      if (category === 'vcs') {
        base.website = row.website || '';
        base.partners = row.partners || [];
      } else {
        base.x = row.x || '';
        base.linkedin = row.linkedin || '';
      }
      return base;
    }

    function reorderRowsByChecked(rows) {
      const unchecked = [];
      const checked = [];
      rows.forEach((row) => {
        if (row && row.checked) {
          checked.push(row);
        } else {
          unchecked.push(row);
        }
      });
      return unchecked.concat(checked);
    }

    function getGridRows() {
      const rows = [];
      if (!state.gridApi) return rows;
      state.gridApi.forEachNode(node => {
        if (node.data) rows.push(node.data);
      });
      return rows;
    }

    function syncLocalDataFromGrid() {
      const rows = getGridRows();
      // VCs use firms array, others use entries
      if (state.currentCategory === 'vcs') {
        DATA.vcs = { ...DATA.vcs, firms: rows };
      } else {
        DATA[state.currentCategory] = { ...DATA[state.currentCategory], entries: rows };
      }
    }

    function applyCheckedOrdering() {
      if (!state.gridApi) return;
      const rows = reorderRowsByChecked(getGridRows());
      // VCs use firms array, others use entries
      if (state.currentCategory === 'vcs') {
        DATA.vcs = { ...DATA.vcs, firms: rows };
      } else {
        DATA[state.currentCategory] = { ...DATA[state.currentCategory], entries: rows };
      }
      state.gridApi.setGridOption('rowData', rows);
      if (state.expandedAll) {
        state.gridApi.forEachNode(node => node.setExpanded(true));
      }
    }

    function setGridData(category) {
      // Handle VCs differently - use firms array with VCDetailRenderer
      if (category === 'vcs') {
        const firms = reorderRowsByChecked(DATA.vcs.firms || []);
        DATA.vcs = { ...DATA.vcs, firms };
        state.gridApi.setGridOption('columnDefs', vcColumnDefs);
        state.gridApi.setGridOption('detailCellRenderer', VCDetailRenderer);
        state.gridApi.setGridOption('detailRowHeight', 280);
        state.gridApi.setGridOption('rowData', firms);
        if (state.expandedAll) {
          state.gridApi.forEachNode(node => node.setExpanded(true));
        }
        return;
      }
      // Reset to default columns and renderer for other categories
      state.gridApi.setGridOption('columnDefs', columnDefs);
      state.gridApi.setGridOption('detailCellRenderer', DetailRenderer);
      state.gridApi.setGridOption('detailRowHeight', 180);
      const rows = reorderRowsByChecked(DATA[category].entries || []);
      DATA[category] = { ...DATA[category], entries: rows };
      state.gridApi.setGridOption('rowData', rows);
      if (state.expandedAll) {
        state.gridApi.forEachNode(node => node.setExpanded(true));
      }
    }

    function addRow() {
      const row = {
        id: `${state.currentCategory}-new-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
        name: 'New Contact',
        city: '',
        tags: [],
        x: '',
        linkedin: '',
        notes: '',
        checked: false
      };
      state.gridApi.applyTransaction({ add: [row], addIndex: 0 });
      syncLocalDataFromGrid();
      if (rowHasRequiredFields(row)) {
        scheduleUpsert(row);
      } else {
        setSyncStatus('Name is required to sync.', false);
      }
    }

    async function callMcp(tool, args) {
      const endpoint = (document.getElementById('mcp-endpoint').value || MCP_ENDPOINT_DEFAULT).trim();
      const apiKey = (document.getElementById('mcp-key').value || MCP_API_KEY_DEFAULT).trim();
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(apiKey ? { 'X-Api-Key': apiKey } : {})
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: `call-${Date.now()}`,
          method: 'tools/call',
          params: { name: tool, arguments: args }
        })
      });
      const json = await res.json();
      if (json.error) {
        throw new Error(json.error.message || 'MCP error');
      }
      // Parse result from JSON-RPC response
      const content = json.result?.content?.[0]?.text;
      if (content) {
        return JSON.parse(content);
      }
      return json.result;
    }

    function scheduleUpsert(row) {
      if (!row || !row.id) return;
      const key = row.id;
      if (pendingUpserts.has(key)) {
        clearTimeout(pendingUpserts.get(key));
      }
      const handle = setTimeout(() => {
        pendingUpserts.delete(key);
        upsertRow(row);
      }, AUTO_UPSERT_DELAY);
      pendingUpserts.set(key, handle);
    }

    async function upsertRow(row) {
      if (!rowHasRequiredFields(row)) {
        setSyncStatus('Name is required to sync.', true);
        return;
      }
      const normalized = normalizeRowForSync(row, state.currentCategory);
      setSyncStatus('Syncing...', false);
      try {
        const payload = {
          category: state.currentCategory,
          id: normalized.id,
          name: normalized.name,
          city: normalized.city,
          tags: normalized.tags,
          notes: normalized.notes,
          checked: normalized.checked
        };
        // Add category-specific fields
        if (state.currentCategory === 'vcs') {
          payload.website = normalized.website;
          payload.partners = normalized.partners;
        } else {
          payload.x = normalized.x;
          payload.linkedin = normalized.linkedin;
        }
        const result = await callMcp('upsert_contact', payload);
        // Check if the upsert actually succeeded
        if (result && result.success === false) {
          setSyncStatus(`Sync failed: ${result.error || 'Unknown error'}`, true);
          return;
        }
        setSyncStatus('Synced.', false);
      } catch (err) {
        setSyncStatus(`Sync failed: ${err.message}`, true);
      }
    }

    async function loadCategory(category) {
      // Prefer MCP live data; fallback to bundled JSON
      try {
        const result = await callMcp('get_contacts', { category, limit: 1000 });
        const contacts = result.contacts || [];
        // Convert API format to local format
        if (category === 'vcs') {
          DATA[category] = { firms: contacts };
          return contacts;
        } else {
          DATA[category] = { category, entries: contacts };
          return contacts;
        }
      } catch (err) {
        try {
          const response = await fetch(`./data/${category}.json?v=${Date.now()}`);
          if (!response.ok) throw new Error('Local fetch failed');
          const json = await response.json();
          DATA[category] = json;
          // VCs use firms array, others use entries
          return category === 'vcs' ? (json.firms || []) : (json.entries || []);
        } catch (fallbackErr) {
          console.error('Failed to load category', category, err, fallbackErr);
          // VCs use firms array, others use entries
          DATA[category] = category === 'vcs' ? { firms: [] } : { entries: [] };
          return [];
        }
      }
    }

    async function init() {
      const gridDiv = document.getElementById('grid');
      agGrid.createGrid(gridDiv, gridOptions);

      await Promise.all(['founders', 'researchers', 'vcs', 'angels', 'hires'].map(loadCategory));
      setGridData(state.currentCategory);

      document.querySelectorAll('.tab').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          btn.classList.add('active');
          state.currentCategory = btn.dataset.category;
          if (state.currentCategory === 'mcp') {
            document.querySelector('.card').style.display = 'none';
            document.getElementById('mcp-panel').classList.add('active');
            return;
          }
          document.querySelector('.card').style.display = 'block';
          document.getElementById('mcp-panel').classList.remove('active');
          setGridData(state.currentCategory);
          state.gridApi.onFilterChanged();
        });
      });

      document.getElementById('search').addEventListener('input', e => {
        state.searchQuery = e.target.value.trim().toLowerCase();
        state.gridApi.onFilterChanged();
      });

      document.getElementById('city-filter').addEventListener('change', e => {
        state.cityFilter = e.target.value;
        state.gridApi.onFilterChanged();
      });

      document.getElementById('btn-add').addEventListener('click', addRow);
      document.getElementById('btn-sync').addEventListener('click', async () => {
        const rows = getGridRows();
        const missingIndex = rows.findIndex(row => !rowHasRequiredFields(row));
        if (missingIndex >= 0) {
          setSyncStatus('Cannot sync: missing name.', true);
          return;
        }
        setSyncStatus('Syncing all rows...', false);
        try {
          let synced = 0;
          for (const row of rows) {
            const normalized = normalizeRowForSync(row, state.currentCategory);
            const payload = {
              category: state.currentCategory,
              id: normalized.id,
              name: normalized.name,
              city: normalized.city,
              tags: normalized.tags,
              notes: normalized.notes,
              checked: normalized.checked
            };
            if (state.currentCategory === 'vcs') {
              payload.website = normalized.website;
              payload.partners = normalized.partners;
            } else {
              payload.x = normalized.x;
              payload.linkedin = normalized.linkedin;
            }
            await callMcp('upsert_contact', payload);
            synced++;
            setSyncStatus(`Synced ${synced}/${rows.length}...`, false);
          }
          // VCs use firms array, others use entries
          if (state.currentCategory === 'vcs') {
            DATA.vcs = { ...DATA.vcs, firms: rows };
          } else {
            DATA[state.currentCategory] = { ...DATA[state.currentCategory], entries: rows };
          }
          setSyncStatus(`All ${rows.length} rows synced.`, false);
        } catch (err) {
          setSyncStatus(`Sync failed: ${err.message}`, true);
        }
      });

      document.getElementById('toggle-expand').addEventListener('click', () => {
        state.expandedAll = !state.expandedAll;
        document.getElementById('toggle-expand').textContent = state.expandedAll ? 'Collapse all' : 'Expand all';
        state.gridApi.forEachNode(node => node.setExpanded(state.expandedAll));
      });

      document.getElementById('btn-download').addEventListener('click', () => {
        const category = state.currentCategory;
        if (category === 'mcp') return;

        let data;
        let filename;
        if (category === 'vcs') {
          data = DATA.vcs;
          filename = 'vcs.json';
        } else {
          data = DATA[category];
          filename = `${category}.json`;
        }

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setSyncStatus(`Downloaded ${filename}`, false);
      });

      document.getElementById('mcp-send').addEventListener('click', async () => {
        const tool = document.getElementById('mcp-tool').value;
        const argsText = document.getElementById('mcp-args').value.trim();
        const status = document.getElementById('mcp-status');
        status.textContent = 'Sending...';
        try {
          const args = parseArgs(argsText);
          await callMcp(tool, args);
          status.textContent = 'Success';
        } catch (err) {
          status.textContent = `Error: ${err.message}`;
        }
      });

      document.getElementById('mcp-copy').addEventListener('click', async () => {
        const endpoint = document.getElementById('mcp-endpoint').value.trim();
        const status = document.getElementById('mcp-status');
        try {
          await navigator.clipboard.writeText(endpoint);
          status.textContent = 'Copied endpoint';
        } catch (err) {
          status.textContent = 'Copy failed';
        }
      });

      document.getElementById('mcp-key-copy').addEventListener('click', async () => {
        const key = document.getElementById('mcp-key').value.trim();
        const status = document.getElementById('mcp-status');
        try {
          await navigator.clipboard.writeText(key);
          status.textContent = 'Copied key';
        } catch (err) {
          status.textContent = 'Copy failed';
        }
      });

      const updateSnippet = () => {
        const endpoint = document.getElementById('mcp-endpoint').value.trim();
        const tool = document.getElementById('mcp-tool').value;
        const argsText = document.getElementById('mcp-args').value.trim();
        let args = {};
        try {
          args = parseArgs(argsText);
        } catch (err) {
          document.getElementById('mcp-snippet').textContent = `// Invalid JSON: ${err.message}`;
          return;
        }
        const apiKey = document.getElementById('mcp-key').value.trim();
        const payload = JSON.stringify({ tool, arguments: args }, null, 2);
        const authHeader = apiKey ? `  -H 'X-Api-Key: ${apiKey}' \\\n` : '';
        const snippet = `curl -s ${endpoint} \\\n  -H 'Content-Type: application/json' \\\n${authHeader}  -d '${payload.replace(/'/g, "'\\''")}'`;
        document.getElementById('mcp-snippet').textContent = snippet;
      };

      document.getElementById('mcp-snippet-copy').addEventListener('click', async () => {
        const status = document.getElementById('mcp-status');
        try {
          await navigator.clipboard.writeText(document.getElementById('mcp-snippet').textContent);
          status.textContent = 'Copied snippet';
        } catch (err) {
          status.textContent = 'Copy failed';
        }
      });

      ['mcp-endpoint', 'mcp-tool', 'mcp-args', 'mcp-key'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateSnippet);
        document.getElementById(id).addEventListener('change', updateSnippet);
      });

      const formatInstructions = (data) => {
        if (!data) return 'No MCP data.';
        const lines = [];
        if (data.description) lines.push(`MCP: ${data.description}`);
        if (data.stats) {
          lines.push('Current data counts:');
          Object.keys(data.stats).forEach((category) => {
            const s = data.stats[category];
            if (s.by_city) {
              lines.push(`- ${category}: ${s.count} rows (SF ${s.by_city.SF}, NYC ${s.by_city.NYC}, other ${s.by_city.other}, unknown ${s.by_city.unknown})`);
            } else {
              lines.push(`- ${category}: ${s.count} rows`);
            }
          });
        }
        if (data.required_fields) {
          lines.push(`Required fields: ${data.required_fields.join(', ')}`);
        }
        if (data.optional_fields) {
          lines.push(`Optional fields: ${data.optional_fields.join(', ')}`);
        }
        if (data.city_values) {
          lines.push(`City values: ${data.city_values.join(', ')}`);
        }
        return lines.join('\n');
      };

      const loadInstructions = async () => {
        const info = document.getElementById('mcp-info');
        try {
          const json = await callMcp('get_instructions', {});
          info.textContent = formatInstructions(json);
        } catch (err) {
          info.textContent = `Error: ${err.message}`;
        }
      };

      updateSnippet();
      loadInstructions();
    }

    function parseArgs(text) {
      if (!text) return {};
      try {
        return JSON.parse(text);
      } catch (err) {
        const cleaned = text.replace(/\\n/g, '\n').replace(/\\"/g, '"');
        return JSON.parse(cleaned);
      }
    }

    init();
  </script>
</body>
</html>
